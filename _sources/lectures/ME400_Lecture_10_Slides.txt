{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Lecture 10 - Pythonic Containers\n",
    " \n",
    "All the way back in [Lecture 1](ME400_Lecture_1.ipynb), the simplest of variable types were presented (namely, `int`, `float`, and `bool`) along with the more complex but indespensable `str` type.  In [Lecture 3](ME400_Lecture_3.ipynb), NumPy was introduced, with its `ndarray` type serving as the workhorse for a variety of applications, particularly those with a numerical flavor.  In this lecture, the built-in Python types `list`, `tuple`, and `dict` are presented, with motivating applications for each."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Objectives\n",
    "\n",
    "By the end of this lesson, you should be able to\n",
    "\n",
    "- Define and use `list` and `tuple` variables.\n",
    "- Define and use `dict` variables.\n",
    "- Explain the difference between *mutable* and *immutable* types."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## What is a *sequential* type?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "**Sequential types** are **container types**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "\n",
    "**Container types** are a collections of values.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "\n",
    "**Sequential types** have elements arranged one after the other (*in sequence*) and (in Python) that can be accessed using `[]`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "> **Question** What types have you learned about already that are sequential?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## The `list` type\n",
    "\n",
    "The most versatile of Python's sequential types is `list`.  A `list` variable can be defined using comma-separated values within square brackets `[]`.  \n",
    "\n",
    "**Examples**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Make a list of the integers 1, 2, and 3 named a\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Make a numpy array of the integers 1, 2, and 3 named b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "However, `list` is more versatile for general programming because its elements can be *arbitrary*. \n",
    "\n",
    "**Example**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Make a list of the values 1, 2.0, and \"3\"  named c\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "Get and set elements of `list` values just like NumPy arrays."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Extract the value \"3\" from the list variable c\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Replace 2.0 with 3.0\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Because we can modify the elements of `list`, it is *mutable*.  See the online readings for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Get the first two elements of c\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Example**: Add a fourth element to c with the value `[99, 100]`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "What else does `list` provide us?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Store the output of dir(list) as items\n",
    "items = dir(list) # What's my type?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Use a for loop and an if statement to print only the \n",
    "# elements of items that do not start with '__'.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "As for `str` variables, the operators `+` and `*` can be used with `list` variables.\n",
    "\n",
    "**Example**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "a = [0]\n",
    "b = [1]\n",
    "# What is a + b?\n",
    "\n",
    "# What is a * 5?\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Example**: Consider the `list` of `list`s `M = [[1, 2, 3], [4, 5, 6]]`.  How would one access the element `[4, 5, 6]`? How would one access the element `5`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "M  = [[1, 2, 3], [4, 5, 6]]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Example**: Use two different ways to check whether `a = [1, 3, 7, 9, 11]` has the element 9.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "a = [1, 3, 7, 9, 11]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## The `tuple` Type\n",
    "\n",
    "The `tuple` type, like `list`, is sequence of elements with arbitrary types.  Defining them is just like `list` values but with `()` and not `[]`. \n",
    "\n",
    "**Examples**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Make a tuple of the values 1, 2.0, and \"3\"  named c\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Access the element equal to \"3\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Change the element equal to 2.0 to the value 3.0\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "What does `tuple` offer us?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "items = dir(tuple) # a list of str names\n",
    "for i in range(len(items)): \n",
    "    if not items[i][0:2] == '__':\n",
    "        print(items[i])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Not much!  Tuple is *immutable* and therefore good when you don't want it (or its elements) to change."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## The `dict` Type\n",
    "\n",
    "Sequences are useful, but not all data is related by position (think a phonebook or password manager).  These latter data are best represented using an *associative* container. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Enter the Python `dict` (dictionary): \n",
    "\n",
    "```python\n",
    "d = {key1: value1, key2: value2, ...}\n",
    "```\n",
    "\n",
    "Get `value1` using `d[key1]`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Example**:  Produce a dictionary with the keys 1, 2, and 3 (`int` values) and the values `'a'`, `'b'`, and `'c'` (`str` values)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# All at once\n",
    "\n",
    "# Start with the keys and values\n",
    "d = {} # This is an empty dictionary\n",
    "keys = [1, 2, 3]\n",
    "vals = ['a', 'b', 'c']\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "**Example**: What happens if we execute `print(d['c'])`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "What do dictionaries offer?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "items = dir(dict) # a list of str names\n",
    "for i in range(len(items)): \n",
    "    if not items[i][0:2] == '__':\n",
    "        print(items[i])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Try a few with the dictionary d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Exercise**: Given `d = {'L': [1, 2, 3], 'T': (11, 12, 13), 'I': 123, 'F': 3.14}`, what are two ways to get `13`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "d = {'L': [1, 2, 3], 'T': (11, 12, 13), 'I': 123, 'F': 3.14}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Exercise**: Demonstrate that `'L'` is a key in `d`.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "**Exercise**: Print out each key and value of `d` one at a time. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Recap\n",
    "\n",
    "You should now be able to\n",
    "\n",
    "- Define and use `list` and `tuple` variables.\n",
    "- Define and use `dict` variables.\n",
    "- Explain the difference between *mutable* and *immutable* types."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Exam 1\n",
    "\n",
    "**Written regrade requests due to me Wednesday by 5 pm.**  You can visit me (not TAs) in office hours for clarification, but we need written record by email of all changes requested.  Solutions (with rubric) are posted.  Rubric is reasonably detailed, but special cases might not match it precisely.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "g = np.array([2.75, 6.0, 7.25, 8.75, 9.5, 10.5, 10.75, 10.75, 11.0, \n",
    "              11.0, 11.75, 12.0, 12.25, 12.5, 12.75, 13.0, 13.25, \n",
    "              13.25, 13.5, 13.75, 14.5, 15.0, 15.0, 15.25, 15.25, \n",
    "              15.25, 15.5, 15.5, 15.5, 15.75, 15.75, 15.75, 15.75, \n",
    "              15.75, 15.75, 16.0, 16.0, 16.0, 16.0, 16.0, 16.0, \n",
    "              16.25, 16.25, 16.25, 16.5, 16.5, 16.5, 16.5, 16.5, \n",
    "              16.75, 16.75, 16.75, 16.75, 17.0, 17.0, 17.25, 17.25, \n",
    "              17.25, 17.25, 17.25, 17.25, 17.5, 17.5, 17.5, 17.5, 17.5, \n",
    "              17.5, 17.75, 17.75, 18.0, 18.0, 18.0, 18.0, 18.25, \n",
    "              18.25, 18.25, 18.5, 18.5, 18.5, 18.5, 18.75, 18.75, 18.75, \n",
    "              18.75, 19.0, 19.0, 19.25, 19.25, 19.25, 19.25, 19.5, \n",
    "              19.5, 19.5, 19.75, 19.75, 19.75, 19.75, 19.75, 20.0])\n",
    "g = 5*g"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "print('  mean = {:6.2f}%'.format(np.mean(g)))\n",
    "print(' stdev = {:6.2f}%'.format(np.std(g)))\n",
    "print('median = {:6.2f}%'.format(np.median(g)))\n",
    "print('   max = {:6.2f}%'.format(np.max(g)))\n",
    "print('   min = {:6.2f}%'.format(np.min(g)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "outputs": [],
   "source": [
    "plt.hist(g, bins=np.arange(20, 101, 2.5), color='purple', alpha=0.5)\n",
    "plt.xlabel('grade (%)',fontsize=16)\n",
    "plt.ylabel('frequency',fontsize=16)\n",
    "plt.plot([np.median(g), np.median(g)],[0, 10], 'b--', lw=2)\n",
    "plt.text(59, 9, 'median', color='blue', fontsize=16)\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Slideshow",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  },
  "livereveal": {
   "scroll": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
